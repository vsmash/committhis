#!/usr/bin/env bash
set -euo pipefail

# bundle-bash.sh: Inline sourced bash files into a single bundle.
# Usage: ./scripts/bundle-bash.sh <entry-file> <output-file>
# Example: ./scripts/bundle-bash.sh maiass.sh maiass.bundle.sh

if [[ ${1:-} == "-h" || ${1:-} == "--help" || $# -lt 2 ]]; then
  echo "Usage: $0 <entry-file> <output-file>" >&2
  exit 1
fi

ENTRY=$1
OUT=$2
ROOT_DIR=$(cd "$(dirname "$0")/.." && pwd)
ENTRY_ABS=$(cd "$(dirname "$ENTRY")" && pwd)/"$(basename "$ENTRY")"
OUT_ABS=$(cd "$(dirname "$OUT")" && pwd)/"$(basename "$OUT")"
ENTRY_DIR=$(cd "$(dirname "$ENTRY_ABS")" && pwd)
LIBEXEC_FROM_ENTRY="$ENTRY_DIR/lib"

# Track included absolute paths to avoid duplication
declare -A INCLUDED

emit_file() {
  local file=$1
  local basedir=$(cd "$(dirname "$file")" && pwd)
  local abs=$(cd "$basedir" && pwd)/"$(basename "$file")"

  # Prevent duplicate inclusion
  if [[ -n "${INCLUDED[$abs]+x}" ]]; then
    return 0
  fi
  INCLUDED[$abs]=1

  local lineno=0
  while IFS= read -r line || [[ -n "$line" ]]; do
    lineno=$((lineno+1))

    # Skip shebangs for inlined files (keep only for entry)
    if [[ $file != "$ENTRY_ABS" && $lineno -eq 1 && "$line" =~ ^#! ]]; then
      continue
    fi

    # Match: source path OR . path (no dynamic expansions)
    # Supports quotes and relative paths
    if [[ $line =~ ^[[:space:]]*(source|\.)[[:space:]]+([^#;]+) ]]; then
      # Extract the path token, trim whitespace, strip quotes
      local raw=${BASH_REMATCH[2]}
      raw=${raw%%[;#]*}
      raw=$(echo "$raw" | sed -e 's/^\s\+//; s/\s\+$//; s/^\"//; s/\"$//; s/^\'\''//; s/\'\''$//')

      # Attempt to resolve a limited set of known variables for inlining
      local resolved_raw="$raw"
      # Handle ${LIBEXEC_DIR} and $LIBEXEC_DIR
      if [[ $resolved_raw == *"LIBEXEC_DIR"* ]]; then
        resolved_raw=${resolved_raw//\$\{LIBEXEC_DIR\}/$LIBEXEC_FROM_ENTRY}
        resolved_raw=${resolved_raw//\$LIBEXEC_DIR/$LIBEXEC_FROM_ENTRY}
      fi
      # Handle ${SCRIPT_PATH} and $SCRIPT_PATH (assume entry dir)
      if [[ $resolved_raw == *"SCRIPT_PATH"* ]]; then
        resolved_raw=${resolved_raw//\$\{SCRIPT_PATH\}/$ENTRY_DIR}
        resolved_raw=${resolved_raw//\$SCRIPT_PATH/$ENTRY_DIR}
      fi

      # If after substitution there are still unknown expansions or globs, keep as-is
      if [[ $resolved_raw == *"$"* || $resolved_raw == *"*"* || $resolved_raw == *"?"* || $resolved_raw == *"["* ]]; then
        echo "$line"
        continue
      fi

      local target
      if [[ $resolved_raw = /* ]]; then
        target="$resolved_raw"
      else
        target="$basedir/$resolved_raw"
      fi

      if [[ -f $target ]]; then
        # Add a marker comment for traceability
        echo ""; echo "# --- Begin inlined: $target ---"; echo ""
        emit_file "$target"
        echo ""; echo "# --- End inlined: $target ---"; echo ""
      else
        # If missing, keep original line
        echo "$line"
      fi
      continue
    fi

    echo "$line"
  done < "$file"
}

# Write output
{
  echo "#!/usr/bin/env bash"
  echo "# Generated by scripts/bundle-bash.sh on $(date -u +%Y-%m-%dT%H:%M:%SZ)"
  echo "# Entry: $ENTRY"
  echo "# Note: This is a bundled file. Do not edit directly."
  echo "export __MAIASS_BUNDLED=1"
  echo
  emit_file "$ENTRY_ABS"
} > "$OUT_ABS"

chmod +x "$OUT_ABS"
echo "Bundled $ENTRY -> $OUT" >&2
